/* ---------------------------------------
IPGen : IP packets generator
Leo Liang <leo.liang@china.com>

Version 1.0 2001/3
----------------------------------------- */

#include <stdio.h>
#include <stdlib.h>

/*#include <stdio.h>*/
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/ip_icmp.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
#include <sys/time.h>
#include <errno.h>
#include <string.h>
#include "ipgen.h"
#include "log.h"

int sockfd;

unsigned short checksum(unsigned short * buf, int len)
{
	int nleft = len;
	unsigned short *w = buf;
	unsigned short answer;
	int sum = 0;

	while (nleft > 1)  {
		sum += *w++;
		nleft -= 2;
	}

	if (nleft == 1)
		sum += htons(*(u_char *)w << 8);

	sum = (sum >> 16) + (sum & 0xffff); /* add hi 16 to low 16 */
	sum += (sum >> 16);         /* add carry */
	answer = ~sum;              /* truncate to 16 bits */
	return (answer);




#if 0
	int nleft = len;
	int sum = 0;
	unsigned short* w = (unsigned short*)buf;

	while (nleft > 1) {
		sum += *w++;
		nleft -= 2;
	}
	if (nleft == 1)
		sum += *(unsigned char*)w;
	sum = (sum >> 16) + (sum & 0xffff);
	sum += (sum >> 16);
	return sum;
#endif
}

/* Convert a address string to struct in_addr,
   the string address may be host name or ip,
   return 1 when success, if string is invalid or host name can't resolved, return 0 */
int AddrConvert(char* address, struct in_addr* inaddr)
{
	struct hostent* he;
	if (inet_aton(address, inaddr) == 1)
		return 1;
	he = gethostbyname(address);
	if ( he != NULL ) {
		*inaddr = *((struct in_addr*)he->h_addr_list[0]);
		return 1;
	} else {
		return 0;
	}
}

void CreateRowSocket(int protocal, char *device)
{
	int on = 1;

	sockfd = socket(AF_INET, SOCK_RAW, protocal);
	if (sockfd < 0) {
		WriteLog(LOG_CRIT, "CreateRowSocket: socket error: %s\n", strerror(errno));
		printf("%s: socket error: %s\n", __FUNCTION__,  strerror(errno));
		exit(1);
	}
	if ( setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &on, sizeof(on)) < 0 ) {
		WriteLog(LOG_CRIT, "CreateRowSocket: socket error: %s\n", strerror(errno));
		printf("%s: socket error: %s\n", __FUNCTION__, strerror(errno));
		exit(1);
	}

	if(!device)
		return;

	if ( setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE, device, strlen(device)+1) < 0 ) {
		WriteLog(LOG_CRIT, "CreateRowSocket: socket error: %s\n", strerror(errno));
		printf("%s: socket error: %s\n", __FUNCTION__, strerror(errno));
		exit(1);
	}

}

/* generate a TCP packet,
   desired size of the packet is len, if actualLen is not NULL, actual size will be put in,
   return a pointer to the packet, caller has duty to free it */
void* GenTCPPacket(int srcPort, int destPort, int len, size_t* actualLen)
{
	void* buf;
	struct tcphdr* tcp;
	int minLen;
	size_t actLen;

	minLen = sizeof(struct tcphdr);
	if (len < minLen)
		actLen = minLen;
	else
		actLen = len;
	
	/* the caller must free this buffer */
	buf = malloc(actLen);
	if ( buf == NULL ) {
		WriteLog(LOG_CRIT, "GenTCPPacket: Alloc %d bytes memory failed\n", actLen);
		return NULL;
	}
	
	tcp = (struct tcphdr*)buf;
	bzero(tcp, sizeof(struct tcphdr));
	tcp->source = htons(srcPort);
	tcp->dest = htons(destPort);
	tcp->seq = random();
	tcp->ack_seq = 0;
	tcp->doff = 5;

	/* fill in the data area */
	if ( actLen > minLen )
		memcpy(buf+minLen, "TCP packet generated by IPGen", actLen-minLen);

	WriteLog(LOG_DEBUG, "GenTCPPacket: Generate a packet, len=%d\n", actLen);
	if ( actualLen )
		*actualLen = actLen;
	return buf;
}

/* generate a UDP packet,
   desired size of the packet is len, if actualLen is not NULL, actual size will be put in,
   return a pointer to the packet, caller has duty to free it */
void* GenUDPPacket(int srcPort, int destPort, int len, size_t* actualLen)
{
	void* buf;
	struct udphdr* udp;
	int minLen;
	size_t actLen;

	minLen = sizeof(struct udphdr);
	if (len < minLen)
		actLen = minLen;
	else
		actLen = len;
	
	/* the caller must free this buffer */
	buf = malloc(actLen);
	if ( buf == NULL ) {
		WriteLog(LOG_CRIT, "GenUDPPacket: Alloc %d bytes memory failed\n", actLen);
		return NULL;
	}
	
	udp = (struct udphdr*)buf;
	udp->source = htons(srcPort);
	udp->dest = htons(destPort);
	udp->len = htons(actLen);
	udp->check = 0;

	/* fill in the data area */
	if ( actLen > minLen )
		memcpy(buf+minLen, "UDP packet generated by IPGen", actLen-minLen);

	WriteLog(LOG_DEBUG, "GenUDPPacket: Generate a packet, len=%d\n", actLen);
	if ( actualLen )
		*actualLen = actLen;
	return buf;
}

/* generate a ICMP ECHO (ping) packet,
   desired size of the packet is len, if actualLen is not NULL, actual size will be put in,
   return a pointer to the packet, caller has duty to free it */
void* GenICMPPacket(int len, size_t* actualLen)
{
	void* buf;
	struct icmphdr* icmp;
	static unsigned int seq = 1;
	int minLen;
	size_t actLen;

	minLen = sizeof(struct icmphdr) + sizeof(struct timeval);
	if (len < minLen)
		actLen = minLen;
	else
		actLen = len;
	
	/* the caller must free this buffer */
	buf = malloc(actLen);
	if ( buf == NULL ) {
		WriteLog(LOG_CRIT, "GenICMPPacket: Alloc %d bytes memory failed\n", actLen);
		return NULL;
	}
	memset(buf, 0, actLen);
	
	icmp = (struct icmphdr*)buf;
	icmp->type = ICMP_ECHO;
	icmp->code = 0;
	icmp->un.echo.id = getpid();
	icmp->un.echo.sequence = htons(seq++);
	gettimeofday((struct timeval*)(icmp+1), NULL);
//	icmp->checksum = 0;
	icmp->checksum = checksum((unsigned short *)icmp, actLen);

	WriteLog(LOG_DEBUG, "GenICMPPacket: Generate a packet, len=%d\n", actLen);
	if ( actualLen )
		*actualLen = actLen;
	return buf;
}

/* generate a IP packet,
   data to put in the packet is content, and data size is contentLen,
   sIP, dIP and proto will be filled in the IP header,
   return a pointer to the packet, caller has duty to free it */
void* GenIPPacket(void* content, size_t contentLen,
					struct in_addr sIP, struct in_addr dIP, unsigned char proto)
{
	void* buf;
	size_t len;
	static short id = 0;
	struct ip* ip;

	len = sizeof(struct ip) + contentLen;
	/* the caller must free this buffer */
	buf = malloc(len);
	if ( buf == NULL ) {
		WriteLog(LOG_CRIT, "GenIPPacket: Alloc %d bytes memory failed\n", len);
		return NULL;
	}
	if (content)
		memcpy(buf+sizeof(struct ip), content, contentLen);

	printf("icmp len : %d\n", contentLen);
	
	ip = (struct ip*)buf;
	ip->ip_v = IPVERSION;
	ip->ip_hl = sizeof(struct ip)>>2;
	ip->ip_tos = 0;
	ip->ip_len = htons(len);
	ip->ip_id = htons(id++);
	ip->ip_off = 0;
	ip->ip_ttl = IPDEFTTL;
	ip->ip_p = proto;
	ip->ip_sum = 0;
	ip->ip_src = sIP;
	ip->ip_dst = dIP;

	return buf;
}

void SendPacket(int sockfd, void* msg, size_t len)
{
	int ret;
	struct sockaddr_in addr;

	/* socket is set IP_HDRINCL, other field of addr is no use */
	addr.sin_family = AF_INET;
	addr.sin_addr = ((struct ip*)msg)->ip_dst;
	ret = sendto(sockfd, msg, len, 0, &addr, sizeof(struct sockaddr_in));
	if (ret < 0)
		WriteLog(LOG_ERR, "SendPacket: Send %d bytes packet failed: %s\n",
			len, strerror(errno));
	else
		WriteLog(LOG_INFO, "SendPacket: Send a packet, len=%d\n", len);
}

/* Send ping packets,
   desired packet size (whole IP packet size) is packetSize */
void SendICMP(char* srcHost, char* destHost, int packetSize, int packetCount)
{
	int i;
	size_t len;
	void* ICMPPacket;
	void* IPPacket;
	struct in_addr sIP;
	struct in_addr dIP;

	if ( !AddrConvert(srcHost, &sIP) ) {
		WriteLog(LOG_ERR, "SendICMP: Source host %s invalid\n", srcHost);
		return;
	}
	if ( !AddrConvert(destHost, &dIP) ) {
		WriteLog(LOG_ERR, "SendICMP: Destination host %s invalid\n", destHost);
		return;
	}
	
	for (i=0; i<packetCount; i++) {
		ICMPPacket = GenICMPPacket(packetSize-sizeof(struct ip), &len);
		if ( ICMPPacket == NULL )
			return;
		IPPacket = GenIPPacket(ICMPPacket, len, sIP, dIP, IPPROTO_ICMP);
		if ( IPPacket == NULL )
			return;
		SendPacket(sockfd, IPPacket, len+sizeof(struct ip));
		free(ICMPPacket);
		free(IPPacket);
		usleep(50);
	}
}

/* Send TCP packets
   desired packet size (whole IP packet size) is packetSize
   note: this function only send TCP packets, but no TCP connection */
void SendTCP(char* srcHost, int srcPort, char* destHost, int destPort,
				int packetSize, int packetCount)
{
	int i;
	size_t len;
	void* TCPPacket;
	void* IPPacket;
	struct in_addr sIP;
	struct in_addr dIP;

	if ( !AddrConvert(srcHost, &sIP) ) {
		WriteLog(LOG_ERR, "SendTCP: Source host %s invalid\n", srcHost);
		return;
	}
	if ( !AddrConvert(destHost, &dIP) ) {
		WriteLog(LOG_ERR, "SendTCP: Destination host %s invalid\n", destHost);
		return;
	}
	
	for (i=0; i<packetCount; i++) {
		TCPPacket = GenTCPPacket(srcPort, destPort, packetSize-sizeof(struct ip), &len);
		if ( TCPPacket == NULL )
			return;
		IPPacket = GenIPPacket(TCPPacket, len, sIP, dIP, IPPROTO_TCP);
		if ( IPPacket == NULL )
			return;
		SendPacket(sockfd, IPPacket, len+sizeof(struct ip));
		free(TCPPacket);
		free(IPPacket);
		usleep(50);
	}
}

/* Send UDP packets
   desired packet size (whole IP packet size) is packetSize */
void SendUDP(char* srcHost, int srcPort, char* destHost, int destPort,
				int packetSize, int packetCount)
{
	int i;
	size_t len;
	void* UDPPacket;
	void* IPPacket;
	struct in_addr sIP;
	struct in_addr dIP;

	if ( !AddrConvert(srcHost, &sIP) ) {
		WriteLog(LOG_ERR, "SendUDP: Source host %s invalid\n", srcHost);
		return;
	}
	if ( !AddrConvert(destHost, &dIP) ) {
		WriteLog(LOG_ERR, "SendUDP: Destination host %s invalid\n", destHost);
		return;
	}
	
	for (i=0; i<packetCount; i++) {
		UDPPacket = GenUDPPacket(srcPort, destPort, packetSize-sizeof(struct ip), &len);
		if ( UDPPacket == NULL )
			return;
		IPPacket = GenIPPacket(UDPPacket, len, sIP, dIP, IPPROTO_UDP);
		if ( IPPacket == NULL )
			return;
		SendPacket(sockfd, IPPacket, len+sizeof(struct ip));
		free(UDPPacket);
		free(IPPacket);
		usleep(50);
	}
}

/* Send IP packets,
   desired packet size (whole IP packet size) is packetSize */
void SendIP(char* srcHost, char* destHost, unsigned char proto, int packetSize, int packetCount)
{
	int i;
	int minLen;
	size_t len;
	void* IPPacket;
	void* data = NULL;
	struct in_addr sIP;
	struct in_addr dIP;

	if ( !AddrConvert(srcHost, &sIP) ) {
		WriteLog(LOG_ERR, "SendIP: Source host %s invalid\n", srcHost);
		return;
	}
	if ( !AddrConvert(destHost, &dIP) ) {
		WriteLog(LOG_ERR, "SendIP: Destination host %s invalid\n", destHost);
		return;
	}
	
	minLen = sizeof(struct ip);
	if (packetSize <= minLen)
		len = 0;
	else {
		len = packetSize-minLen;
		data = malloc(len);
		/* fill in the data area */
		memcpy(data, "RAW IP packet generated by IPGen", len);
	}
	
	for (i=0; i<packetCount; i++) {
		IPPacket = GenIPPacket(data, len, sIP, dIP, proto);
		if ( IPPacket == NULL )
			return;
		SendPacket(sockfd, IPPacket, len+sizeof(struct ip));
		free(IPPacket);
		usleep(50);
	}
	free(data);
}

